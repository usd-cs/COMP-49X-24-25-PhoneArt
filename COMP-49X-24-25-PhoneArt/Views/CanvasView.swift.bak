//
//  CanvasView.swift
//  COMP-49X-24-25-PhoneArt
//
//  Created by Aditya Prakash on 12/06/24.
//

import SwiftUI
import UIKit
import Photos

/// A view that displays a draggable canvas with coordinate axes and a red circle.
/// The canvas can be moved around the screen and reset to its original position.
/// Features:
/// - Draggable canvas with bounce effects
/// - Coordinate system with X and Y axes
/// - Properties panel for shape manipulation
/// - Reset position functionality
struct CanvasView: View {
// MARK: - Properties
 /// Current offset position of the canvas relative to its initial centered position
 @State private var offset = CGSize(
        width: (UIScreen.main.bounds.width - 1600) / 2,
        height: (UIScreen.main.bounds.height - 1800) / 2
    )
     /// Previous offset position of the canvas, used for calculating the next position during drag gestures
    @State internal var lastOffset: CGSize = CGSize(
        width: (UIScreen.main.bounds.width - 1600) / 2,
        height: (UIScreen.main.bounds.height - 1800) / 2
    )
     /// Properties panel visibility state
    @State internal var showProperties = false
     /// Shape transformation properties
    @State private var shapeRotation: Double = 0
    @State private var shapeScale: Double = 1.0
    @State private var shapeLayer: Double = 0
    @State private var shapeSkewX: Double = 0
    @State private var shapeSkewY: Double = 0
    @State private var shapeSpread: Double = 0
    @State private var shapeHorizontal: Double = 0
    @State private var shapeVertical: Double = 0
    @State private var shapePrimitive: Double = 1
     @State private var layerCount: Double = 1 // Set default to 1
     /// Add zoom state property
    @State private var zoomLevel: Double = 1.0
    /// Add state to track the starting zoom level during a pinch gesture
    @State private var startingZoomLevel: Double = 1.0
     /// Add new state variable
    @State internal var showColorShapes = false
     /// Add new state variable for shapes panel
    @State internal var showShapesPanel = false
    /// Add state variable for the gallery panel
   @State internal var showGalleryPanel = false
    /// Tracks whether we are switching between panels (rather than opening/closing)
    @State private var isSwitchingPanels = false
     /// The color currently applied to the base shape on the canvas
    /// This color can be changed through the ColorSelectionPanel
    @State private var shapeColor: Color = .red  // Default to red
    /// The currently selected shape type
    @State private var selectedShape: ShapesPanel.ShapeType = .circle  // Default to circle
    /// Use the shared color preset manager for real-time updates
    @ObservedObject private var colorPresetManager = ColorPresetManager.shared
     /// State variable to force view updates when color presets change
    @State private var colorUpdateTrigger = UUID()
    /// State variable to track background color changes
    @State private var backgroundColorTrigger = UUID()
    /// State variable to track stroke setting changes
    @State private var strokeSettingsTrigger = UUID()
     @StateObject internal var firebaseService: FirebaseService // Make internal and declare type
     /// Add state for showing alerts
    @State internal var showAlert = false // Make internal
    @State internal var alertMessage = "" // Make internal
    @State internal var alertTitle = "" // Make internal
    
    /// State variable to store the UUID of the saved artwork
    @State internal var confirmedArtworkId: IdentifiableArtworkID? = nil // Make internal
    /// State variable to control the visibility of the save artwork prompt
    @State private var showingSavePrompt = false
    /// State variable to store the title entered by the user in the prompt
    @State private var artworkTitleInput = ""
    /// State variable for showing the import artwork sheet
    @State private var showImportSheet = false
    /// State variable to track the currently loaded artwork (if any)
    @State private var loadedArtworkData: ArtworkData? = nil
    // Add state for tracking photo saving
    @State private var isSavingPhoto = false
   
    // Add state variables to handle gallery full selection
    @State private var galleryFullArtworks: [ArtworkData] = []
    @State private var showGalleryFullAlert = false
    @State private var pendingArtworkData: (String, String?) = ("", nil) // (artworkString, title)
    @State private var showArtworkReplaceSheet = false
    @State private var galleryThumbnails: [String: UIImage] = [:] // Dictionary to store thumbnails [artworkId: UIImage]
   
    // Add these state variables after the other @State declarations around line 80-90
    @State private var hasUnsavedChanges = false
    @State private var lastCheckedArtworkString: String? = nil
   
    // Add these state variables after existing @State declarations
    @State private var pendingAction: PendingAction? = nil
    @State private var showUnsavedChangesAlert = false
   
    // Add this enum to handle different types of actions that might discard changes
    private enum PendingAction {
        case newCanvas
        case importArtwork
        case loadGalleryArtwork(ArtworkData)
    }
   
    // Add initializer for dependency injection
    init(firebaseService: FirebaseService = FirebaseService()) {
        _firebaseService = StateObject(wrappedValue: firebaseService)
        // Need to initialize other @State properties manually if not default
        // For properties with default initial values like offset, showProperties, etc.,
        // Swift initializes them automatically. If any @State property didn't have
        // a default value assigned inline, you'd initialize it here.
    }
    
    // Make internal for testing
    internal func validatePrimitive(_ primitive: Double) -> Double {
        max(1.0, min(6.0, primitive))
    }
     /// Computed vertical offset for the canvas when properties panel or color shapes panel is shown
    internal var canvasVerticalOffset: CGFloat {
        // Estimate heights: Standard ~350, Gallery ~550
        let standardPanelOffset: CGFloat = -150 // Shift up less for shorter panels
        let galleryPanelOffset: CGFloat = -220  // Shift up more for the taller gallery

        if showGalleryPanel {
            return galleryPanelOffset
        } else if showProperties || showColorShapes || showShapesPanel {
            return standardPanelOffset
        } else {
            return 0 // No panel, no offset
        }
    }
     /// Computed minimum zoom level to fit canvas width to screen width
    private var minZoomLevel: Double {
        UIScreen.main.bounds.width / 1600.0
    }
     // Make internal for testing
    internal func validateZoom(_ zoom: Double) -> Double {
        max(minZoomLevel, min(3.0, zoom))  // Updated to use dynamic minimum
    }
     // MARK: - Body
    var body: some View {
        mainContentView
            .ignoresSafeArea()
            .alert("Save Artwork", isPresented: $showingSavePrompt) {
                TextField("Enter Artwork Title (Optional)", text: $artworkTitleInput)
                    .autocapitalization(.words)
                    .accessibilityIdentifier("Artwork Title TextField")
                Button("Cancel", role: .cancel) { }
                Button("Save") {
                    let titleToSave = artworkTitleInput.trimmingCharacters(in: .whitespacesAndNewlines)
                    saveArtwork(title: titleToSave.isEmpty ? nil : titleToSave)
                }
                .accessibilityIdentifier("Save Artwork Button")
            } message: {
                Text("Enter an optional title for your artwork.")
            }
            .applyAnimationChanges(showProperties: showProperties, 
                                  showColorShapes: showColorShapes, 
                                  showShapesPanel: showShapesPanel, 
                                  isSwitchingPanels: isSwitchingPanels)
            .applyNotificationListeners(colorUpdateTrigger: $colorUpdateTrigger,
                                       backgroundColorTrigger: $backgroundColorTrigger,
                                       strokeSettingsTrigger: $strokeSettingsTrigger,
                                       checkForUnsavedChanges: checkForUnsavedChanges)
            .applyAlerts(showAlert: $showAlert, 
                        alertTitle: alertTitle, 
                        alertMessage: alertMessage,
                        showGalleryFullAlert: $showGalleryFullAlert,
                        saveToPhotos: saveToPhotos,
                        showArtworkReplaceSheet: $showArtworkReplaceSheet)
            .sheet(isPresented: $showArtworkReplaceSheet) {
                ArtworkReplaceSheet(
                    artworks: galleryFullArtworks,
                    thumbnails: galleryThumbnails,
                    onSelect: { selectedArtwork in
                        replaceArtwork(with: selectedArtwork)
                    },
                    onCancel: {
                        showArtworkReplaceSheet = false
                    }
                )
            }
            .applyOverlays(confirmedArtworkId: confirmedArtworkId,
                          showImportSheet: showImportSheet,
                          onImportSuccess: applyImportedArtwork)
            .alert("Unsaved Changes", isPresented: $showUnsavedChangesAlert) {
                Button("Cancel", role: .cancel) {
                    pendingAction = nil
                }
                Button("Discard Changes", role: .destructive) {
                    executePendingAction()
                }
                Button("Save First") {
                    if let artwork = loadedArtworkData, artwork.pieceId != nil {
                        updateCurrentArtwork(artwork: artwork)
                    } else {
                        artworkTitleInput = loadedArtworkData?.title ?? ""
                        showingSavePrompt = true
                    }
                }
            } message: {
                Text(getAlertMessage())
            }
            .applyShapeChangeListeners(checkForUnsavedChanges: checkForUnsavedChanges)
    }

    // MARK: - View Components
    // Main content view
    private var mainContentView: some View {
        ZStack {
            canvasArea
            
            // Share button in upper left
            VStack(spacing: 10) {
                makeShareButton()
                    .padding(.bottom, 30)
            }
            .padding(.top, 50)
            .padding(.leading, 20)
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topLeading)
            
            // Reset button and zoom slider in upper right
            VStack(spacing: 10) {
                makeResetButton()
                    .padding(.bottom, 30)
                makeZoomSlider()
            }
            .padding(.top, 50)
            .padding(.trailing, -30)
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topTrailing)
            
            // Bottom controls
            bottomControlsView
            
            // Panels
            panelsOverlayView
        }
    }

    // Canvas area with gestures
    private var canvasArea: some View {
        GeometryReader { geometry in
            colorPresetManager.backgroundColor
                .frame(width: 2400, height: 2600)
                .contentShape(Rectangle())
            
            Canvas { context, size in
                drawShapes(context: context, size: size)
            }
            .accessibilityIdentifier("Canvas")
            .frame(width: 1600, height: 1800)
            .border(Color(uiColor: .label), width: 2)
            .scaleEffect(zoomLevel)
            .offset(x: offset.width, y: offset.height + canvasVerticalOffset)
            .animation(.easeInOut(duration: 0.25), value: canvasVerticalOffset)
        }
        .gesture(
            DragGesture()
                .onChanged(handleDragChange)
                .onEnded(handleDragEnd)
        )
        .gesture(
            MagnificationGesture()
                .onChanged { value in
                    let newZoom = startingZoomLevel * value
                    zoomLevel = validateZoom(newZoom)
                }
                .onEnded { value in
                    startingZoomLevel = zoomLevel
                }
        )
        .onAppear {
            startingZoomLevel = zoomLevel
            loadInitialArtwork()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                checkForUnsavedChanges()
            }
        }
    }

    // Bottom controls with artwork info and buttons
    private var bottomControlsView: some View {
        VStack(spacing: 8) {
            Spacer()
            makeArtworkInfoBanner()
                .padding(.bottom, 4)
                .zIndex(2)
            
            // Bottom button bar
            HStack(alignment: .center, spacing: 0) {
                Spacer()
                makePropertiesButton()
                Spacer()
                makeColorShapesButton()
                Spacer()
                makeShapesButton()
                Spacer()
                makeGalleryButton()
                Spacer()
                makeCloseButton()
                Spacer()
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 20)
        }
    }

    // Panels overlay view
    private var panelsOverlayView: some View {
        Group {
            if showProperties {
                panelOverlay {
                    PropertiesPanel(
                        rotation: $shapeRotation,
                        scale: $shapeScale,
                        layer: $shapeLayer,
                        skewX: $shapeSkewX,
                        skewY: $shapeSkewY,
                        spread: $shapeSpread,
                        horizontal: $shapeHorizontal,
                        vertical: $shapeVertical,
                        primitive: $shapePrimitive,
                        isShowing: $showProperties,
                        onSwitchToColorShapes: switchToColorShapes,
                        onSwitchToShapes: switchToShapes,
                        onSwitchToGallery: switchToGallery
                    )
                }
            }
            
            if showColorShapes {
                panelOverlay {
                    ColorPropertiesPanel(
                        isShowing: $showColorShapes,
                        selectedColor: $shapeColor,
                        onSwitchToProperties: switchToProperties,
                        onSwitchToShapes: switchToShapes,
                        onSwitchToGallery: switchToGallery
                    )
                }
            }
            
            if showShapesPanel {
                panelOverlay {
                    ShapesPanel(
                        selectedShape: $selectedShape,
                        isShowing: $showShapesPanel,
                        onSwitchToProperties: switchToProperties,
                        onSwitchToColorProperties: switchToColorShapes,
                        onSwitchToGallery: switchToGallery
                    )
                }
            }
            
            if showGalleryPanel {
                panelOverlay {
                    GalleryPanel(
                        isShowing: $showGalleryPanel,
                        onSwitchToProperties: switchToProperties,
                        onSwitchToColorShapes: switchToColorShapes,
                        onSwitchToShapes: switchToShapes,
                        onLoadArtwork: loadArtwork
                    )
                }
            }
        }
    }

    // MARK: - View Modifiers
    // Add view modifier extensions to clean up the body
    extension View {
        func applyAnimationChanges(showProperties: Bool, showColorShapes: Bool, showShapesPanel: Bool, isSwitchingPanels: Bool) -> some View {
            self
                .onChange(of: showProperties) { _, newValue in
                    if !isSwitchingPanels && newValue {
                        withAnimation(.easeInOut(duration: 0.25)) {}
                    }
                }
                .onChange(of: showColorShapes) { _, newValue in
                    if !isSwitchingPanels && newValue {
                        withAnimation(.easeInOut(duration: 0.25)) {}
                    }
                }
                .onChange(of: showShapesPanel) { _, newValue in
                    if !isSwitchingPanels && newValue {
                        withAnimation(.easeInOut(duration: 0.25)) {}
                    }
                }
        }
        
        func applyNotificationListeners(colorUpdateTrigger: Binding<UUID>, backgroundColorTrigger: Binding<UUID>, strokeSettingsTrigger: Binding<UUID>, checkForUnsavedChanges: @escaping () -> Void) -> some View {
            self
                .onReceive(NotificationCenter.default.publisher(for: Notification.Name("ColorPresetsChanged"))) { _ in
                    colorUpdateTrigger.wrappedValue = UUID()
                    checkForUnsavedChanges()
                }
                .onReceive(NotificationCenter.default.publisher(for: Notification.Name("BackgroundColorChanged"))) { _ in
                    backgroundColorTrigger.wrappedValue = UUID()
                    checkForUnsavedChanges()
                }
                .onReceive(NotificationCenter.default.publisher(for: Notification.Name("StrokeSettingsChanged"))) { _ in
                    strokeSettingsTrigger.wrappedValue = UUID()
                    checkForUnsavedChanges()
                }
        }
        
        func applyAlerts(showAlert: Binding<Bool>, alertTitle: String, alertMessage: String, showGalleryFullAlert: Binding<Bool>, saveToPhotos: @escaping () -> Void, showArtworkReplaceSheet: Binding<Bool>) -> some View {
            self
                .alert(isPresented: showAlert) {
                    Alert(
                        title: Text(alertTitle),
                        message: Text(alertMessage),
                        dismissButton: .default(Text("OK"))
                    )
                }
                .alert("Gallery Full", isPresented: showGalleryFullAlert) {
                    Button("Cancel", role: .cancel) { }
                    Button("Save to Photos") {
                        saveToPhotos()
                        showGalleryFullAlert.wrappedValue = false
                    }
                    Button("Select Artwork to Replace") {
                        showArtworkReplaceSheet.wrappedValue = true
                    }
                } message: {
                    Text("Your gallery is full (12 artworks maximum). You need to replace an existing artwork to save a new one.")
                }
        }
        
        func applyOverlays(confirmedArtworkId: IdentifiableArtworkID?, showImportSheet: Bool, onImportSuccess: @escaping (String) -> Void) -> some View {
            self.overlay {
                ZStack {
                    if let confirmedId = confirmedArtworkId {
                        Color.black.opacity(0.4)
                            .ignoresSafeArea()
                            .onTapGesture {}
                        
                        SaveConfirmationView(artworkId: confirmedId.id) {
                            // Action to dismiss the modal handled in parent view
                        }
                        .transition(.opacity.animation(.easeInOut))
                    }
                    
                    if showImportSheet {
                        Color.black.opacity(0.4)
                            .ignoresSafeArea()
                            .onTapGesture {
                                // Dismiss on background tap handled in parent view
                            }
                        
                        ImportArtworkView(
                            onImportSuccess: { artworkString in
                                onImportSuccess(artworkString)
                                // Dismissal handled in parent view
                            },
                            onClose: {
                                // Close handled in parent view
                            }
                        )
                        .transition(.opacity.animation(.easeInOut))
                    }
                }
            }
        }
        
        func applyShapeChangeListeners(checkForUnsavedChanges: @escaping () -> Void) -> some View {
            self
                .onChange(of: \CanvasView.shapeRotation) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeScale) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeLayer) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeSkewX) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeSkewY) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeSpread) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeHorizontal) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapeVertical) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.shapePrimitive) { _, _ in checkForUnsavedChanges() }
                .onChange(of: \CanvasView.selectedShape) { _, _ in checkForUnsavedChanges() }
        }
    }

    /// Draws shapes on the canvas above the origin point
    /// - Parameters:
    ///   - context: The graphics context to draw in
    ///   - size: The size of the canvas
    private func drawShapes(context: GraphicsContext, size: CGSize) {
        let circleRadius = 30.0
        let centerX = size.width/2
        let centerY = size.height/2
        let center = CGPoint(x: centerX, y: centerY)
 
        // Draw center point of the canvas
        drawCenterDot(context: context, at: center, color: .black)
 
        let numberOfLayers = max(0, min(72, Int(shapeLayer)))
        if numberOfLayers > 0 {
            drawLayers(
                context: context,
                layers: numberOfLayers,
                center: center,
                radius: circleRadius
            )
        }
    }
     /// Draws a small dot to indicate a center point
    /// - Parameters:
    ///   - context: The graphics context to draw in
    ///   - point: The position to draw the dot
    ///   - color: The color of the dot
    private func drawCenterDot(context: GraphicsContext, at point: CGPoint, color: Color) {
        let dotRadius = 2.0
        let dotPath = Path(ellipseIn: CGRect(
            x: point.x - dotRadius,
            y: point.y - dotRadius,
            width: dotRadius * 2,
            height: dotRadius * 2
        ))
        context.fill(dotPath, with: .color(color))
    }
     /// Draws multiple layers of shapes with cumulative rotation
    /// - Parameters:
    ///   - context: The graphics context to draw in
    ///   - layers: Number of layers to draw
    ///   - center: Center point for rotation
    ///   - radius: Radius of the circle
    private func drawLayers(
        context: GraphicsContext,
        layers: Int,
        center: CGPoint,
        radius: Double
    ) {
        // Get the number of primitives (1-6)
        let primitiveCount = Int(validatePrimitive(shapePrimitive))
 
        for layerIndex in 0..<layers {
            // For each primitive in the current layer, draw evenly spaced shapes
            for primitiveIndex in 0..<primitiveCount {
                // Calculate the angle offset for each primitive shape (evenly distributed across 360Â°)
                let primitiveAngleOffset = (360.0 / Double(primitiveCount)) * Double(primitiveIndex)
  
                drawSingleShape(
                    context: context,
                    layerIndex: layerIndex,
                    primitiveAngleOffset: primitiveAngleOffset,
                    center: center,
                    radius: radius
                )
            }
        }
    }
     /// Draws a single shape with appropriate rotation, opacity, and color
    /// - Parameters:
    ///   - context: The graphics context to draw in
    ///   - layerIndex: Current layer number (0 is base layer)
    ///   - primitiveAngleOffset: Additional angle offset for primitive distribution
    ///   - center: Center point for rotation
    ///   - radius: Radius of the circle
    /// The shape is drawn using either the selected color or cycling through preset colors
    private func drawSingleShape(
        context: GraphicsContext,
        layerIndex: Int,
        primitiveAngleOffset: Double,
        center: CGPoint,
        radius: Double
    ) {
        let layerContext = context
  
        // Calculate the actual angle for this layer (clockwise) plus primitive offset
        let angleInDegrees = (shapeRotation * Double(layerIndex)) + primitiveAngleOffset
        let angleInRadians = angleInDegrees * (.pi / 180)
  
        // Scale compounds with each layer, but significantly reduced
        let scaleFactor = 0.06125  // Reduced from 0.25 to 0.125 to halve the scale effect strength
        let layerScale = pow(1.0 + (shapeScale - 1.0) * scaleFactor, Double(layerIndex + 1))
        let scaledRadius = radius * layerScale
  
        // Apply spread to move shapes away from center
        let spreadDistance = max(shapeSpread * Double(layerIndex), Double(layerIndex))
        let spreadX = spreadDistance * cos(angleInRadians)
        let spreadY = spreadDistance * sin(angleInRadians)
  
        // Calculate final position with horizontal and vertical offsets
        let finalX = center.x + scaledRadius * cos(angleInRadians) + spreadX + shapeHorizontal
        let finalY = center.y + scaledRadius * sin(angleInRadians) + spreadY - shapeVertical
 
        // Create base rectangle centered at the final position
        let baseRect = CGRect(
            x: finalX - scaledRadius,
            y: finalY - scaledRadius,
            width: scaledRadius * 2,
            height: scaledRadius * 2
        )
  
        // Create the path based on the selected shape
        let shapePath: Path
        switch selectedShape {
        case .circle:
            shapePath = Path(ellipseIn: baseRect)
        case .square:
            shapePath = Path(CGRect(
                x: finalX - scaledRadius,
                y: finalY - scaledRadius,
                width: scaledRadius * 2,
                height: scaledRadius * 2
            ))
        case .triangle:
            var path = Path()
            path.move(to: CGPoint(x: finalX, y: finalY - scaledRadius))
            path.addLine(to: CGPoint(x: finalX - scaledRadius, y: finalY + scaledRadius))
            path.addLine(to: CGPoint(x: finalX + scaledRadius, y: finalY + scaledRadius))
            path.closeSubpath()
            shapePath = path
        case .hexagon:
            shapePath = ShapeUtils.createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 6)
        case .star:
            shapePath = ShapeUtils.createStarPath(center: CGPoint(x: finalX, y: finalY), innerRadius: scaledRadius * 0.4, outerRadius: scaledRadius, points: 5)
        case .rectangle:
            shapePath = Path(CGRect(
                x: finalX - scaledRadius,
                y: finalY - scaledRadius * 0.6,
                width: scaledRadius * 2,
                height: scaledRadius * 1.2
            ))
        case .oval:
            shapePath = Path(ellipseIn: CGRect(
                x: finalX - scaledRadius,
                y: finalY - scaledRadius * 0.6,
                width: scaledRadius * 2,
                height: scaledRadius * 1.2
            ))
        case .diamond:
            var path = Path()
            path.move(to: CGPoint(x: finalX, y: finalY - scaledRadius))
            path.addLine(to: CGPoint(x: finalX + scaledRadius, y: finalY))
            path.addLine(to: CGPoint(x: finalX, y: finalY + scaledRadius))
            path.addLine(to: CGPoint(x: finalX - scaledRadius, y: finalY))
            path.closeSubpath()
            shapePath = path
        case .pentagon:
            shapePath = ShapeUtils.createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 5)
        case .octagon:
            shapePath = ShapeUtils.createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 8)
        case .arrow:
            shapePath = ShapeUtils.createArrowPath(center: CGPoint(x: finalX, y: finalY), size: scaledRadius)
        case .rhombus:
            var path = Path()
            path.move(to: CGPoint(x: finalX, y: finalY - scaledRadius))
            path.addLine(to: CGPoint(x: finalX + scaledRadius * 0.8, y: finalY))
            path.addLine(to: CGPoint(x: finalX, y: finalY + scaledRadius))
            path.addLine(to: CGPoint(x: finalX - scaledRadius * 0.8, y: finalY))
            path.closeSubpath()
            shapePath = path
        case .parallelogram:
            var path = Path()
            path.move(to: CGPoint(x: finalX - scaledRadius + scaledRadius * 0.4, y: finalY - scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX + scaledRadius + scaledRadius * 0.4, y: finalY - scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX + scaledRadius - scaledRadius * 0.4, y: finalY + scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX - scaledRadius - scaledRadius * 0.4, y: finalY + scaledRadius * 0.6))
            path.closeSubpath()
            shapePath = path
        case .trapezoid:
            var path = Path()
            path.move(to: CGPoint(x: finalX - scaledRadius * 0.8, y: finalY - scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX + scaledRadius * 0.8, y: finalY - scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX + scaledRadius, y: finalY + scaledRadius * 0.6))
            path.addLine(to: CGPoint(x: finalX - scaledRadius, y: finalY + scaledRadius * 0.6))
            path.closeSubpath()
            shapePath = path
        }
   
        // Create separate transformations and apply them in the correct sequence
   
        // The key insight: Skew transformation naturally shifts the object's center
        // To fix this, we need to:
        // 1. Create the shape centered at the origin (0,0)
        // 2. Apply skew and rotation transformations (in local coordinates)
        // 3. Then translate the result to its final position
   
        // First we'll create a shape centered at the origin and a separate transform to position it
        _ = shapePath
   
        // For positioning, we use a separate transform
        _ = CGAffineTransform(translationX: 0, y: 0) // We'll modify this later
   
        // Now create the transforms for rotation and skew (relative to origin)
        var shapeTransform = CGAffineTransform.identity
   
        // 1. Apply rotation
        if abs(angleInRadians) > 0.001 {
            shapeTransform = shapeTransform.rotated(by: CGFloat(angleInRadians))
        }
   
        // 2. Apply skew (relative to origin)
        if abs(shapeSkewX) > 0.01 || abs(shapeSkewY) > 0.01 {
            // Use smaller range to prevent extreme distortion
            // Convert degrees directly to radians for 1:1 mapping
            let skewXRad = shapeSkewX * (.pi / 180) 
            let skewYRad = shapeSkewY * (.pi / 180)
   
            // Build skew transform (this creates a skew centered at 0,0)
            if abs(shapeSkewX) > 0.01 {
                let shearX = CGFloat(tan(skewXRad))
                let skewXTransform = CGAffineTransform(a: 1, b: 0, c: shearX, d: 1, tx: 0, ty: 0)
                shapeTransform = shapeTransform.concatenating(skewXTransform)
            }
   
            if abs(shapeSkewY) > 0.01 {
                let shearY = CGFloat(tan(skewYRad))
                let skewYTransform = CGAffineTransform(a: 1, b: shearY, c: 0, d: 1, tx: 0, ty: 0)
                shapeTransform = shapeTransform.concatenating(skewYTransform)
            }
        }
     
        // Now combine the transforms:
        // 1. Create the shape path (already at position finalX, finalY)
        // 2. Transform it to the origin (0,0) by subtracting finalX, finalY
        // 3. Apply rotation and skew transforms to the centered shape
        // 4. Transform it back to final position
    
        // Complete transform chain:
        let toOriginTransform = CGAffineTransform(translationX: -finalX, y: -finalY)
        let backToPositionTransform = CGAffineTransform(translationX: finalX, y: finalY)
     
        // Chain the transforms in correct order:
        // First to origin, then apply shape transformations, then back to position
        let finalTransform = toOriginTransform
            .concatenating(shapeTransform)
            .concatenating(backToPositionTransform)
     
        // Apply the complete transform chain to get the final path
        let transformedPath = shapePath.applying(finalTransform)
     
        // Determine color for this layer - cycle through presets based on visible presets
        let layerColor = colorPresetManager.colorForPosition(position: layerIndex)
    
        // Determine the final opacity for this layer
        let baseOpacity = colorPresetManager.shapeAlpha  // Get the global alpha setting
        
        // Modified opacity calculation:
        // When baseOpacity is 1.0 (100%), don't reduce opacity for layers
        // When baseOpacity is less than 1.0, use the existing falloff logic
        let layerOpacity: Double
        if baseOpacity >= 0.99 {  // Using 0.99 instead of 1.0 to account for floating point imprecision
            layerOpacity = 1.0  // Keep all layers fully opaque when alpha is 100%
        } else {
            // For alpha < 100%, maintain the existing behavior with reduced opacity for deeper layers
            layerOpacity = layerIndex == 0 ? baseOpacity : baseOpacity * 0.8
        }

        // Explicitly construct the final color with the calculated layerOpacity,
        // ignoring any potential alpha component in the original layerColor.
        let finalColor = layerColor.opacity(layerOpacity)

        // Fill the shape with the explicitly constructed final color
        layerContext.fill(transformedPath, with: .color(finalColor))
        
        // Apply stroke if width is greater than 0
        if colorPresetManager.strokeWidth > 0 {
            layerContext.stroke(
                transformedPath,
                with: .color(colorPresetManager.strokeColor),  // Don't apply alpha to stroke
                lineWidth: CGFloat(colorPresetManager.strokeWidth)
            )
        }
    }
     // MARK: - Gesture Handlers
     /// Handles continuous updates during drag gesture
    /// - Parameter value: DragGesture.Value
    private func handleDragChange(value: DragGesture.Value) {
        withAnimation(.interactiveSpring(
            response: 0.3,
            dampingFraction: 0.7,
            blendDuration: 0.2
        )) {
            offset.width = lastOffset.width + value.translation.width
            offset.height = lastOffset.height + value.translation.height
        }
    }
     /// Handles the end of drag gesture
    /// - Parameter value: DragGesture.Value
    private func handleDragEnd(value: DragGesture.Value) {
        withAnimation(.spring(
            response: 0.4,
            dampingFraction: 0.8,
            blendDuration: 0.3
        )) {
            offset.width = lastOffset.width + value.translation.width
            offset.height = lastOffset.height + value.translation.height
        }
  
        lastOffset = offset
    }
     /// Resets the canvas position to the center of the screen
    internal func resetPosition() {
        withAnimation(.spring(
            response: 0.8,
            dampingFraction: 0.5,
            blendDuration: 1.0
        )) {
            offset = CGSize(
                width: (UIScreen.main.bounds.width - 1600) / 2,
                height: (UIScreen.main.bounds.height - 1800) / 2
            )
            lastOffset = offset
        }
    }
     // MARK: - UI Components
     /// Creates the reset position button
    private func makeResetButton() -> some View {
        Button(action: resetPosition) {
            Rectangle() // Keep the Rectangle as the base shape
                .foregroundColor(.clear) // Make the rectangle transparent
                .frame(width: 40, height: 40)
                .background(Color(uiColor: .systemBackground)) // Apply background color
                .cornerRadius(8) // Apply corner radius
                .overlay( // Apply icon overlay
                    Image(systemName: "arrow.down.forward.and.arrow.up.backward")
                        .font(.system(size: 20))
                        .foregroundColor(Color(uiColor: .systemBlue)) // Use systemBlue for icon
                )
                .overlay( // Apply border overlay
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
        }
        .accessibilityIdentifier("Reset Position")
    }
     /// Creates the properties panel toggle button
    private func makePropertiesButton() -> some View {
        Button(action: {
           if showProperties {
               showProperties = false
           } else {
               switchToProperties()
            }
        }) {
            Rectangle()
                .foregroundColor(Color(uiColor: .systemBackground))
               .frame(width: 50, height: 50)
                .cornerRadius(8)
                .overlay(
                    Image(systemName: "slider.horizontal.3")
                       .font(.system(size: 22))
                        .foregroundColor(Color(uiColor: .systemBlue))
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
        }
        .accessibilityIdentifier("Properties Button")
    }
     /// Creates an alternate button to toggle the properties panel
    private func makeColorShapesButton() -> some View {
        Button(action: {
           if showColorShapes {
               showColorShapes = false
           } else {
               switchToColorShapes()
            }
        }) {
            Rectangle()
                .foregroundColor(Color(uiColor: .systemBackground))
               .frame(width: 50, height: 50)
                .cornerRadius(8)
                .overlay(
                    Image(systemName: "square.3.stack.3d")
                       .font(.system(size: 22))
                        .foregroundColor(Color(uiColor: .systemBlue))
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
        }
        .accessibilityIdentifier("Color Shapes Button")
    }
     /// Creates a button for the shapes panel
    private func makeShapesButton() -> some View {
        Button(action: {
           if showShapesPanel {
               showShapesPanel = false
           } else {
               switchToShapes()
            }
        }) {
            Rectangle()
                .foregroundColor(Color(uiColor: .systemBackground))
               .frame(width: 50, height: 50)
                .cornerRadius(8)
                .overlay(
                    Image(systemName: "square.on.square")
                       .font(.system(size: 22))
                        .foregroundColor(Color(uiColor: .systemBlue))
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
        }
        .accessibilityIdentifier("Shapes Button")
    }

     /// Creates the zoom control slider with + and - indicators
    private func makeZoomSlider() -> some View {
        VStack(spacing: 8) {
            Image(systemName: "plus")
                .font(.system(size: 16, weight: .bold))
                .foregroundColor(Color(uiColor: .secondaryLabel))
                .padding(.bottom, 50)
  
            Slider(
                value: $zoomLevel,
                in: minZoomLevel...3.0,
                step: 0.1
            )
            .rotationEffect(.degrees(-90))
            .frame(width: 120)
            .accessibilityIdentifier("Zoom Slider")
   
            Image(systemName: "minus")
                .font(.system(size: 16, weight: .bold))
                .foregroundColor(Color(uiColor: .secondaryLabel))
                .padding(.top, 50)
        }
        .padding(8)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color(uiColor: .systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
                .frame(width: 40)
       )
    }
     /// Creates the close button that's always visible
    private func makeCloseButton() -> some View {
        Button(action: {
           // Close all panels
                showProperties = false
                showColorShapes = false
                showShapesPanel = false
           showGalleryPanel = false
        }) {
            Rectangle()
                .foregroundColor(Color(uiColor: .systemBackground))
               .frame(width: 50, height: 50)
                .cornerRadius(8)
                .overlay(
                    Image(systemName: "xmark")
                       .font(.system(size: 22))
                        .foregroundColor(Color(uiColor: .systemBlue))
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                )
        }
        .accessibilityIdentifier("Close Button")
    }
     /// Creates the share button group for the top navigation bar
    private func makeShareButton() -> some View {
        return VStack(spacing: 20) {
            // --- Top Button Menu (New / Import) ---
            Menu {
                Button(action: resetCanvasToDefault) {
                    Label("New Canvas", systemImage: "doc.badge.plus")
                }
                .accessibilityIdentifier("New Canvas Button")

                Button(action: showImportMenu) {
                    Label("Import from ID...", systemImage: "square.and.arrow.down")
                }
                .accessibilityIdentifier("Import Button")
                
            } label: {
                buttonIcon(systemName: "plus") // Keep the plus icon for the menu
            }
            .accessibilityIdentifier("New/Import Menu")

            // --- Bottom Button Menu (Share/Save) ---
            Menu {
                // Conditional Save Button
                if let artworkToUpdate = loadedArtworkData {
                    Button(action: { updateCurrentArtwork(artwork: artworkToUpdate) }) {
                        Label("Save", systemImage: "square.and.arrow.down")
                    }
                    .accessibilityIdentifier("Save Update Button")
                } // Else (no loaded artwork), this button doesn't appear

                // --- Save as New Button ---
                Button(action: { showSaveAsNewPrompt() }) {
                    Label("Save as New...", systemImage: "square.and.arrow.down.on.square")
                }
                .accessibilityIdentifier("Save as New Button")

                // --- Save to Photos Button ---
                Button(action: saveToPhotos) {
                    Label("Save to Photos", systemImage: "photo")
                }
                .accessibilityIdentifier("Save to Photos Button")
                
                // Add other share options here
            } label: {
                buttonIcon(systemName: "square.and.arrow.up")
            }
            .accessibilityIdentifier("Share Button")
        }
    }


       /// Creates a button for the Gallery.
       private func makeGalleryButton() -> some View {
           Button(action: {
              switchToGallery() // Use the correct callback method
           }) {
              Rectangle()
                  .foregroundColor(Color(uiColor: .systemBackground))
                  .frame(width: 50, height: 50) // Set size
                  .cornerRadius(8)
                  .overlay(
                      Image(systemName: "photo.on.rectangle.angled")
                          .font(.system(size: 22)) // Set size
                          .foregroundColor(Color(uiColor: .systemBlue))
                  )
                  .overlay(
                      RoundedRectangle(cornerRadius: 8)
                          .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                  )
           }
           .accessibilityIdentifier("Gallery Button")
       }


     // Modify access level
     // private func saveArtwork() {
     internal func saveArtwork(title: String? = nil) {
        let artworkString = getCurrentArtworkString()
        
        // Save for potential later use if gallery is full
        pendingArtworkData = (artworkString, title)
        
        Task {
            do {
                let (docRef, isGalleryFull, existingArtworks) = try await firebaseService.saveArtwork(artworkData: artworkString, title: title)
                
                if isGalleryFull {
                    // Gallery is full, show alert
                    await MainActor.run {
                        galleryFullArtworks = existingArtworks
                        
                        // Generate thumbnails for the artworks
                        generateThumbnails(for: existingArtworks)
                        
                        showGalleryFullAlert = true
                        
                        // Clear pending action if gallery is full
                        pendingAction = nil
                    }
                } else if let pieceRef = docRef {
                    let newPieceId = pieceRef.documentID
                    
                    // Update the loadedArtworkData state to reflect the newly saved piece
                    self.loadedArtworkData = ArtworkData(
                        deviceId: firebaseService.getDeviceId(), // Get current device ID
                        artworkString: artworkString,
                        timestamp: Date(), // Use current time
                        title: title,
                        pieceId: newPieceId
                    )
                    
                    // Reset unsaved changes flag since we just saved the artwork
                    hasUnsavedChanges = false
                    lastCheckedArtworkString = artworkString
                    
                    await firebaseService.listAllPieces()
                    
                    await MainActor.run {
                        confirmedArtworkId = IdentifiableArtworkID(id: newPieceId)
                        
                        // Execute any pending action that was waiting for the save
                        if pendingAction != nil {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                self.executePendingAction()
                            }
                        }
                    }
                }
            } catch {
                // Display error alert
                DispatchQueue.main.async {
                    alertTitle = "Error Saving"
                    alertMessage = error.localizedDescription
                    showAlert = true
                    
                    // Clear pending action on error
                    pendingAction = nil
                }
            }
        }
    }
  
   /// Save artwork to Photos library using ImageRenderer
   private func saveToPhotos() {
       Task { @MainActor in
              // 1. Define the content to render (Canvas + Background)
              let contentToRender = ZStack {
                   colorPresetManager.backgroundColor
                   Canvas { context, size in
                      // Use the exact same drawing logic as the main canvas
                       drawShapes(context: context, size: size)
                   }
               }
              // Use the desired export size (e.g., canvas size without border)
              .frame(width: 1600, height: 1800)


              // 2. Create the ImageRenderer
              let renderer = ImageRenderer(content: contentToRender)


              // Optional: Improve quality if needed by setting scale
              renderer.scale = UIScreen.main.scale // Use screen scale for better quality


              // 3. Render the image (this can take time, keep ProgressView)
              isSavingPhoto = true


              // Asynchronously render the image
              if let uiImage = renderer.uiImage {
                  // 4. Call the updated ExportService function
                  ExportService.saveImageToPhotoLibrary(image: uiImage) { success, error in
                      // Update UI on the main thread
                      isSavingPhoto = false // Hide progress view

                  
                   if success {
                          alertTitle = "Success"
                          alertMessage = "Artwork saved to Photos successfully!"
                   } else {
                          alertTitle = "Error"
                          alertMessage = error?.localizedDescription ?? "Failed to save to Photos"
                      }
                      showAlert = true // Show the result alert
                  }
              } else {
                  // Handle rendering failure
                  isSavingPhoto = false
                  alertTitle = "Error"
                  alertMessage = "Failed to render artwork image."
                  showAlert = true
              }
          }
      }


    // Function to apply imported artwork data to the canvas state
    private func applyImportedArtwork(_ artworkString: String) {
        print("Applying imported artwork string:")
        // Decode the string into a dictionary
        let decodedParams = ArtworkData.decode(from: artworkString)
        print("Decoded parameters: \(decodedParams)")

        // Update state variables - use helper function for safe unwrapping and type conversion
        self.selectedShape = ShapesPanel.ShapeType(rawValue: decodedParams["shape"] ?? "circle") ?? .circle
        self.shapeRotation = doubleValue(from: decodedParams["rotation"]) ?? 0
        self.shapeScale = doubleValue(from: decodedParams["scale"]) ?? 1.0
        self.shapeLayer = doubleValue(from: decodedParams["layer"]) ?? 0
        self.shapeSkewX = doubleValue(from: decodedParams["skewX"]) ?? 0
        self.shapeSkewY = doubleValue(from: decodedParams["skewY"]) ?? 0
        self.shapeSpread = doubleValue(from: decodedParams["spread"]) ?? 0
        self.shapeHorizontal = doubleValue(from: decodedParams["horizontal"]) ?? 0
        self.shapeVertical = doubleValue(from: decodedParams["vertical"]) ?? 0
        self.shapePrimitive = doubleValue(from: decodedParams["primitive"]) ?? 1.0
        
        // Update colors via ColorPresetManager
        if let colorsString = decodedParams["colors"] {
            let importedColors = ArtworkData.reconstructColors(from: colorsString)
            // Ensure we have exactly 10 presets if necessary, padding with defaults if needed
            var finalPresets = importedColors
            if finalPresets.count < 10 {
                let defaultColors: [Color] = [.purple, .blue, .pink, .yellow, .green, .red, .orange, .cyan, .indigo, .mint]
                for i in finalPresets.count..<10 {
                    finalPresets.append(defaultColors[i % defaultColors.count])
                }
            } else if finalPresets.count > 10 {
                finalPresets = Array(finalPresets.prefix(10))
            }
            colorPresetManager.colorPresets = finalPresets
            print("Applied \(finalPresets.count) color presets.")
        }

        if let backgroundString = decodedParams["background"],
           let bgColor = ArtworkData.hexToColor(backgroundString) {
            colorPresetManager.backgroundColor = bgColor
            print("Applied background color: \(bgColor)")
        }
        
        // Apply saved preset count if available
        if let presetCountString = decodedParams["presetCount"], let presetCount = Int(presetCountString) {
            // Validate the range (1-10)
            colorPresetManager.numberOfVisiblePresets = max(1, min(10, presetCount))
            print("Applied numberOfVisiblePresets: \(presetCount)")
        }
        
        // --- Re-add Apply color mode settings --- 
        if let useRainbowString = decodedParams["useRainbow"] {
            colorPresetManager.useDefaultRainbowColors = (useRainbowString == "true")
            print("Applied useDefaultRainbowColors: \(colorPresetManager.useDefaultRainbowColors)")
        }

        if let styleString = decodedParams["rainbowStyle"], let style = Int(styleString) {
            colorPresetManager.rainbowStyle = style
            print("Applied rainbowStyle: \(style)")
        }

        if let hueAdjString = decodedParams["hueAdj"], let hueAdj = Double(hueAdjString) {
            colorPresetManager.hueAdjustment = hueAdj
            print("Applied hueAdjustment: \(hueAdj)")
        }

        if let satAdjString = decodedParams["satAdj"], let satAdj = Double(satAdjString) {
            colorPresetManager.saturationAdjustment = satAdj
            print("Applied saturationAdjustment: \(satAdj)")
        }
        // --- End Re-add ---

        // Note: Stroke and Alpha are not currently saved in artworkString, 
        // so they are not applied during import.

        print("Finished applying imported artwork.")
        
        // --- Apply Stroke and Alpha --- 
        if let strokeColorString = decodedParams["strokeColor"], 
           let color = ArtworkData.hexToColor(strokeColorString) {
            colorPresetManager.strokeColor = color
            print("Applied strokeColor: \(color)")
        }

        // Use the existing doubleValue helper for strokeWidth and alpha
        if let strokeWidth = doubleValue(from: decodedParams["strokeWidth"]) {
            // Clamp stroke width to a reasonable range (e.g., 0-20)
            colorPresetManager.strokeWidth = max(0, min(20.0, strokeWidth))
            print("Applied strokeWidth: \(colorPresetManager.strokeWidth)")
        }

        if let alpha = doubleValue(from: decodedParams["alpha"]) {
            // Clamp alpha to 0-1 range
            colorPresetManager.shapeAlpha = max(0.0, min(1.0, alpha))
            print("Applied shapeAlpha: \(colorPresetManager.shapeAlpha)")
        }
        // --- End Apply Stroke and Alpha ---
    }

    // Helper function to safely convert String? to Double?
    private func doubleValue(from stringValue: String?) -> Double? {
        guard let string = stringValue else { return nil }
        return Double(string)
    }

    /// Generic function to handle panel switching logic
   private func switchPanel(hideOthersAndShow panelToShow: Binding<Bool>) {
       isSwitchingPanels = true
       showProperties = false
       showColorShapes = false
       showShapesPanel = false
       showGalleryPanel = false
       panelToShow.wrappedValue = true
       isSwitchingPanels = false
   }
   
   /// Switch to Properties panel
   private func switchToProperties() {
       switchPanel(hideOthersAndShow: $showProperties)
   }
   
   /// Switch to Color Shapes panel
   private func switchToColorShapes() {
       switchPanel(hideOthersAndShow: $showColorShapes)
   }
   
   /// Switch to Shapes panel
   private func switchToShapes() {
       switchPanel(hideOthersAndShow: $showShapesPanel)
   }
  
   /// Switch to Gallery panel
   private func switchToGallery() {
       switchPanel(hideOthersAndShow: $showGalleryPanel)
   }


   /// Helper view modifier to wrap panel content with standard layout and transition
   @ViewBuilder
   private func panelOverlay<Content: View>(@ViewBuilder content: () -> Content) -> some View {
       VStack {
           Spacer()
           content()
       }
       .zIndex(3) // Ensure panels appear above the canvas content
       .transition(!isSwitchingPanels ? .asymmetric(
           insertion: .move(edge: .bottom),
           removal: .move(edge: .bottom)
       ) : .identity) // Use standard transition unless switching panels
   }

    /// Loads the parameters from a saved ArtworkData object into the current canvas state.
    private func loadArtwork(artwork: ArtworkData) {
        // Check for unsaved changes first
        if hasUnsavedChanges {
            setShowUnsavedChangesAlert(action: .loadGalleryArtwork(artwork))
            return
        }
        
        // Otherwise proceed with loading
        performLoadArtwork(artwork: artwork)
    }

    // Create a new method for the actual load functionality
    private func performLoadArtwork(artwork: ArtworkData) {
        print("[CanvasView] Loading artwork: \(artwork.title ?? "Untitled") (ID: \(artwork.id))")
        
        // Store the loaded artwork data, including its pieceId
        self.loadedArtworkData = artwork

        let decodedParams = ArtworkData.decode(from: artwork.artworkString)
        print("[CanvasView] Decoded params for load: \(decodedParams)")

        // Helper to safely extract double values
        func doubleValue(from key: String, default defaultValue: Double) -> Double {
            guard let stringValue = decodedParams[key], let value = Double(stringValue) else {
                print("[CanvasView Load] Warning: Could not decode Double for key '\(key)', using default: \(defaultValue)")
                return defaultValue
            }
            // Note: Validation happens within ArtworkData.decode, so we trust the values here
            return value
        }

        // Update shape parameters
        shapeRotation = doubleValue(from: "rotation", default: shapeRotation)
        shapeScale = doubleValue(from: "scale", default: shapeScale)
        shapeLayer = doubleValue(from: "layer", default: shapeLayer)
        shapeSkewX = doubleValue(from: "skewX", default: shapeSkewX)
        shapeSkewY = doubleValue(from: "skewY", default: shapeSkewY)
        shapeSpread = doubleValue(from: "spread", default: shapeSpread)
        shapeHorizontal = doubleValue(from: "horizontal", default: shapeHorizontal)
        shapeVertical = doubleValue(from: "vertical", default: shapeVertical)
        shapePrimitive = doubleValue(from: "primitive", default: shapePrimitive)

        // Update selected shape type
        if let shapeString = decodedParams["shape"],
           let loadedShape = ShapesPanel.ShapeType(rawValue: shapeString) {
            selectedShape = loadedShape
            print("[CanvasView Load] Loaded shape: \(loadedShape.rawValue)")
        } else {
             print("[CanvasView Load] Warning: Could not decode 'shape'.")
        }

        // Update ColorPresetManager with decoded color settings
        // This handles presets, background, rainbow settings, stroke, alpha, etc.
        ColorPresetManager.shared.update(from: decodedParams)

        // Set the loaded artwork string as the reference point
        lastCheckedArtworkString = artwork.artworkString
        
        // Force artwork to be considered "saved" initially
        hasUnsavedChanges = false
        
        // Let the UI update before checking for differences
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            // Debug compare to see if strings match after loading
            let currentString = self.getCurrentArtworkString()
            print("[CanvasView] Checking if loaded artwork matches current state:")
            self.debugCompareArtworkStrings(loaded: artwork.artworkString, current: currentString)
            
            // Check if values actually match
            self.checkForUnsavedChanges()
        }

        print("[CanvasView] Finished loading artwork.")
    }

    /// Shows the prompt for entering a title when saving new artwork.
    private func showSaveAsNewPrompt() {
        artworkTitleInput = "" // Reset title input
        showingSavePrompt = true // Show the alert
    }

    /// Updates the currently loaded artwork in Firestore with the current canvas state.
    private func updateCurrentArtwork(artwork: ArtworkData) {
        guard let pieceId = artwork.pieceId else {
            // Should not happen if the button is only shown for loaded artwork
            print("Error: Attempted to update artwork without a pieceId.")
            alertTitle = "Error"
            alertMessage = "Cannot update artwork: Missing original ID."
            showAlert = true
            return
        }
        print("Attempting to update artwork with pieceId: \(pieceId)")

        let currentArtworkString = getCurrentArtworkString()

        Task {
            do {
                try await firebaseService.updateArtwork(artwork: artwork, newArtworkString: currentArtworkString)
                
                // Update the loadedArtworkData state to reflect the updated piece
                self.loadedArtworkData = ArtworkData(
                    deviceId: artwork.deviceId,
                    artworkString: currentArtworkString,
                    timestamp: Date(), // Use current time for the update
                    title: artwork.title,
                    pieceId: pieceId
                )
                
                // Reset unsaved changes flag since we just updated the artwork
                hasUnsavedChanges = false
                lastCheckedArtworkString = currentArtworkString
                
                await MainActor.run {
                    // Show success feedback
                    alertTitle = "Success"
                    alertMessage = "Artwork '\(artwork.title ?? "Untitled")' updated successfully!"
                    showAlert = true
                    
                    // Execute any pending action that was waiting for the save
                    if pendingAction != nil {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                            self.executePendingAction()
                        }
                    }
                }
            } catch {
                await MainActor.run {
                    alertTitle = "Error Updating"
                    alertMessage = error.localizedDescription
                    showAlert = true
                    
                    // Clear pending action on error
                    pendingAction = nil
                }
            }
        }
    }

    /// Helper function to generate the artwork string from the current canvas state.
    /// Returns a semicolon-separated string of key-value pairs in a consistent order.
    private func getCurrentArtworkString() -> String {
        // Get the validated data map
        let validatedData = ArtworkData.createValidatedDataMap(
            shapeType: selectedShape,
            rotation: shapeRotation,
            scale: shapeScale,
            layer: shapeLayer,
            skewX: shapeSkewX,
            skewY: shapeSkewY,
            spread: shapeSpread,
            horizontal: shapeHorizontal,
            vertical: shapeVertical,
            primitive: shapePrimitive,
            colorPresets: colorPresetManager.colorPresets,
            backgroundColor: colorPresetManager.backgroundColor,
            useDefaultRainbowColors: colorPresetManager.useDefaultRainbowColors,
            rainbowStyle: colorPresetManager.rainbowStyle,
            hueAdjustment: colorPresetManager.hueAdjustment,
            saturationAdjustment: colorPresetManager.saturationAdjustment,
            numberOfVisiblePresets: colorPresetManager.numberOfVisiblePresets,
            strokeColor: colorPresetManager.strokeColor,
            strokeWidth: colorPresetManager.strokeWidth,
            shapeAlpha: colorPresetManager.shapeAlpha
        )
        
        // Sort the keys for consistent ordering
        let sortedKeys = validatedData.keys.sorted()
        
        // Create the string with sorted keys
        return sortedKeys.map { key in
            "\(key):\(validatedData[key]!)"
        }.joined(separator: ";")
    }

    /// Resets the canvas state and color settings to their default values.
    private func resetCanvasToDefault() {
        // Check for unsaved changes first
        if hasUnsavedChanges {
            setShowUnsavedChangesAlert(action: .newCanvas)
            return
        }
        
        // Otherwise proceed with reset
        performResetCanvasToDefault()
    }

    // Create a new method for the actual reset functionality
    private func performResetCanvasToDefault() {
        print("[CanvasView] Resetting canvas to default state.")

        // Reset shape parameters
        shapeRotation = 0
        shapeScale = 1.0
        shapeLayer = 0
        shapeSkewX = 0
        shapeSkewY = 0
        shapeSpread = 0
        shapeHorizontal = 0
        shapeVertical = 0
        shapePrimitive = 1
        selectedShape = .circle // Default shape

        // Reset color manager
        ColorPresetManager.shared.resetToDefaults()

        // Clear loaded artwork data
        loadedArtworkData = nil
        
        // Reset unsaved changes tracking
        hasUnsavedChanges = false
        lastCheckedArtworkString = nil

        // Reset zoom and position
        resetPosition() // Call the existing position reset function
        zoomLevel = 1.0   // Reset zoom level to default

        print("[CanvasView] Canvas reset complete.")
    }

    /// Loads initial artwork when the app starts
    private func loadInitialArtwork() {
        Task {
            do {
                // Attempt to get artwork from Firebase
                let artworks = try await firebaseService.getArtwork()
                
                if let mostRecentArtwork = artworks.first {
                    // Found artwork in gallery, load the most recent one
                    print("[CanvasView] Loading most recent artwork: \(mostRecentArtwork.title ?? "Untitled")")
                    await MainActor.run {
                        loadArtwork(artwork: mostRecentArtwork)
                    }
                } else {
                    // No artwork found, create randomized artwork
                    print("[CanvasView] No artwork found, creating randomized artwork")
                    await MainActor.run {
                        createRandomizedArtwork()
                    }
                }
            } catch {
                // Error fetching artwork, create randomized artwork
                print("[CanvasView] Error fetching artwork: \(error.localizedDescription)")
                await MainActor.run {
                    createRandomizedArtwork()
                }
            }
        }
    }
    
    /// Creates an artwork with randomized properties
    private func createRandomizedArtwork() {
        // Random shape type from available options
        let shapeTypes: [ShapesPanel.ShapeType] = [.circle, .square, .triangle, .pentagon, .star]
        selectedShape = shapeTypes.randomElement() ?? .circle
        
        // Random shape properties within reasonable ranges
        shapeRotation = Double.random(in: 0...360)
        shapeScale = Double.random(in: 0.8...1.5)
        shapeLayer = Double.random(in: 0...5)
        shapeSkewX = Double.random(in: 0...30)
        shapeSkewY = Double.random(in: 0...30)
        shapeSpread = Double.random(in: 5...40)
        shapeHorizontal = Double.random(in: -50...50)
        shapeVertical = Double.random(in: -50...50)
        shapePrimitive = Double.random(in: 1...5).rounded()
        
        // Create random colors for the presets (using hue rotation for variety)
        var randomColors: [Color] = []
        for i in 0..<10 {
            let hue = Double.random(in: 0...1)
            let saturation = Double.random(in: 0.7...1.0)
            let brightness = Double.random(in: 0.7...1.0)
            randomColors.append(Color(hue: hue, saturation: saturation, brightness: brightness))
        }
        
        // Apply colors to presets and background
        colorPresetManager.colorPresets = randomColors
        colorPresetManager.backgroundColor = Color(hue: Double.random(in: 0...1), 
                                                  saturation: Double.random(in: 0.1...0.3), 
                                                  brightness: Double.random(in: 0.9...1.0))
                                                  
        // Random stroke and alpha settings
        colorPresetManager.strokeWidth = Double.random(in: 0...5)
        colorPresetManager.strokeColor = randomColors.randomElement() ?? .black
        colorPresetManager.shapeAlpha = Double.random(in: 0.7...1.0)
        
        print("[CanvasView] Created randomized artwork")
    }

    // Add a function to handle replacing an existing artwork
    private func replaceArtwork(with selectedArtwork: ArtworkData) {
        let (artworkString, title) = pendingArtworkData
        
        Task {
            do {
                let pieceRef = try await firebaseService.saveArtworkReplacing(
                    artworkData: artworkString,
                    title: title,
                    replacingArtwork: selectedArtwork
                )
                
                let newPieceId = pieceRef.documentID
                
                // Update the loadedArtworkData state to reflect the newly saved piece
                self.loadedArtworkData = ArtworkData(
                    deviceId: firebaseService.getDeviceId(),
                    artworkString: artworkString,
                    timestamp: Date(),
                    title: title,
                    pieceId: newPieceId
                )
                
                await firebaseService.listAllPieces()
                
                await MainActor.run {
                    confirmedArtworkId = IdentifiableArtworkID(id: newPieceId)
                    showArtworkReplaceSheet = false // Close the selection sheet
                }
            } catch {
                await MainActor.run {
                    alertTitle = "Error Replacing Artwork"
                    alertMessage = error.localizedDescription
                    showAlert = true
                }
            }
        }
    }

    // Add a function to generate thumbnails for artwork selection
    private func generateThumbnails(for artworks: [ArtworkData]) {
        Task(priority: .userInitiated) {
            var generated: [String: UIImage] = [:]
            let targetSize = CGSize(width: 50, height: 50) // Small preview size for the list
            
            for artwork in artworks {
                // Skip if we already have a thumbnail
                if let existingThumb = galleryThumbnails[artwork.id] {
                    generated[artwork.id] = existingThumb
                    continue
                }
                
                // Decode artwork parameters for rendering
                if let params = decodeArtworkParameters(from: artwork.artworkString) {
                    // Create a renderer for the artwork
                    let renderer = ImageRenderer(content: ArtworkRendererView(params: params))
                    renderer.scale = UIScreen.main.scale
                    
                    if let uiImage = renderer.uiImage {
                        // Resize the image to thumbnail size
                        if let resizedImage = resizeImage(image: uiImage, targetSize: targetSize) {
                            generated[artwork.id] = resizedImage
                        }
                    }
                }
            }
            
            // Update thumbnails on the main thread
            await MainActor.run {
                self.galleryThumbnails = generated
            }
        }
    }
    
    // Helper for resizing images
    private func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage? {
        let size = image.size
        let widthRatio = targetSize.width / size.width
        let heightRatio = targetSize.height / size.height
        let ratio = min(widthRatio, heightRatio)
        let newSize = CGSize(width: size.width * ratio, height: size.height * ratio)
        let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: rect)
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return newImage
    }
    
    // Helper to decode artwork parameters
    private func decodeArtworkParameters(from artworkString: String) -> ArtworkParameters? {
        let decodedParams = ArtworkData.decode(from: artworkString)
        
        // Helper for doubles
        func doubleValue(from key: String, default defaultValue: Double) -> Double {
            guard let stringValue = decodedParams[key], let value = Double(stringValue) else {
                return defaultValue
            }
            return value
        }
        
        guard let shapeString = decodedParams["shape"],
              let shapeType = ShapesPanel.ShapeType(rawValue: shapeString) else {
            return nil // Cannot render without shape type
        }
        
        let colors = ArtworkData.reconstructColors(from: decodedParams["colors"] ?? "")
        let background = ArtworkData.hexToColor(decodedParams["background"] ?? "") ?? .white
        
        // Decode color mode flag
        let useRainbowFlag = (decodedParams["useRainbow"] ?? "false") == "true"
        
        // Decode rainbow settings
        let rainbowStyle = Int(decodedParams["rainbowStyle"] ?? "") ?? 0
        let hueAdjustment = Double(decodedParams["hueAdj"] ?? "") ?? 0.0
        let saturationAdjustment = Double(decodedParams["satAdj"] ?? "") ?? 0.0
        
        // Decode stroke and alpha
        let shapeAlpha = doubleValue(from: "alpha", default: 1.0)
        let strokeWidth = doubleValue(from: "strokeWidth", default: 0.0)
        let strokeColor = ArtworkData.hexToColor(decodedParams["strokeColor"] ?? "") ?? .black
        
        return ArtworkParameters(
            shapeType: shapeType,
            rotation: doubleValue(from: "rotation", default: 0),
            scale: doubleValue(from: "scale", default: 1.0),
            layer: doubleValue(from: "layer", default: 1.0),
            skewX: doubleValue(from: "skewX", default: 0),
            skewY: doubleValue(from: "skewY", default: 0),
            spread: doubleValue(from: "spread", default: 0),
            horizontal: doubleValue(from: "horizontal", default: 0),
            vertical: doubleValue(from: "vertical", default: 0),
            primitive: doubleValue(from: "primitive", default: 1.0),
            colorPresets: colors,
            backgroundColor: background,
            useDefaultRainbowColors: useRainbowFlag,
            rainbowStyle: rainbowStyle,
            hueAdjustment: hueAdjustment,
            saturationAdjustment: saturationAdjustment,
            shapeAlpha: shapeAlpha,
            strokeWidth: strokeWidth,
            strokeColor: strokeColor
        )
    }

    // Add this method after the getCurrentArtworkString method around line 1320
    /// Checks if there are unsaved changes by comparing the current settings with the loaded artwork
    private func checkForUnsavedChanges() {
        // If no artwork is loaded, no changes to track
        guard let loadedArtwork = loadedArtworkData else {
            hasUnsavedChanges = false
            return
        }
        
        // Get current artwork string
        let currentArtworkString = getCurrentArtworkString()
        
        // If strings are identical, return immediately
        if loadedArtwork.artworkString == currentArtworkString {
            hasUnsavedChanges = false
            print("[DEBUG] Raw artwork strings are identical - artwork is saved")
            return
        }
        
        // Debug: compare the raw strings to spot possible issues
        debugCompareArtworkStrings(loaded: loadedArtwork.artworkString, current: currentArtworkString)
        
        // Parse both strings to get parameter dictionaries
        let loadedParams = ArtworkData.decode(from: loadedArtwork.artworkString)
        let currentParams = ArtworkData.decode(from: currentArtworkString)
        
        // Debug: print all differences
        print("[DEBUG] Comparing loaded vs current artwork parameters:")
        
        // Initialize to false - we'll set to true if we find any differences
        hasUnsavedChanges = false
        
        // Check shape type
        if loadedParams["shape"] != currentParams["shape"] {
            print("[DEBUG] Shape mismatch: loaded=\(loadedParams["shape"] ?? "nil"), current=\(currentParams["shape"] ?? "nil")")
            hasUnsavedChanges = true
            return
        }
        
        // Compare numeric properties with tolerance for floating point
        func compareDoubleValues(key: String) -> Bool {
            guard let loadedStr = loadedParams[key], let currentStr = currentParams[key],
                  let loadedVal = Double(loadedStr), let currentVal = Double(currentStr) else {
                print("[DEBUG] Missing \(key): loaded=\(loadedParams[key] ?? "nil"), current=\(currentParams[key] ?? "nil")")
                return false
            }
            
            // Use a larger tolerance for floating point comparison
            let tolerance = 0.001
            let matching = abs(loadedVal - currentVal) <= tolerance
            
            if !matching {
                print("[DEBUG] \(key) mismatch: loaded=\(loadedVal), current=\(currentVal), diff=\(abs(loadedVal - currentVal))")
            }
            return matching
        }
        
        // Compare all numeric properties
        let numericKeys = ["rotation", "scale", "layer", "skewX", "skewY", "spread", 
                          "horizontal", "vertical", "primitive"]
        
        for key in numericKeys {
            if !compareDoubleValues(key: key) {
                hasUnsavedChanges = true
                return
            }
        }
        
        // Special handling for strokeWidth and alpha which might be optional
        if loadedParams["strokeWidth"] != nil || currentParams["strokeWidth"] != nil {
            if !compareDoubleValues(key: "strokeWidth") {
                hasUnsavedChanges = true
                return
            }
        }
        
        if loadedParams["alpha"] != nil || currentParams["alpha"] != nil {
            if !compareDoubleValues(key: "alpha") {
                hasUnsavedChanges = true
                return
            }
        }
        
        // Check colors (this is a bit more complex due to string format)
        func compareColorValues(key: String) -> Bool {
            let loadedColors = loadedParams[key]?.uppercased() ?? ""
            let currentColors = currentParams[key]?.uppercased() ?? ""
            
            // If they're exactly the same, return true immediately
            if loadedColors == currentColors {
                return true
            }
            
            print("[DEBUG] \(key) mismatch: loaded=\(loadedColors), current=\(currentColors)")
            
            // For the "colors" key, need special handling of the color array
            if key == "colors" {
                // Split into individual color values
                let loadedColorArray = loadedColors.split(separator: ",").map { String($0) }
                let currentColorArray = currentColors.split(separator: ",").map { String($0) }
                
                // Check if arrays have same length
                if loadedColorArray.count != currentColorArray.count {
                    print("[DEBUG] Different number of colors: loaded=\(loadedColorArray.count), current=\(currentColorArray.count)")
                    return false
                }
                
                // Compare each color with tolerance
                for i in 0..<loadedColorArray.count {
                    if !areColorsVisuallyEquivalent(loadedColorArray[i], currentColorArray[i]) {
                        print("[DEBUG] Color at position \(i) differs significantly: loaded=\(loadedColorArray[i]), current=\(currentColorArray[i])")
                        return false
                    }
                }
                
                // If we get here, all colors are equivalent within tolerance
                print("[DEBUG] Colors are visually equivalent despite hex differences")
                return true
            } else {
                // For single colors (background, strokeColor), compare with tolerance
                return areColorsVisuallyEquivalent(loadedColors, currentColors)
            }
        }
        
        let colorKeys = ["colors", "background", "strokeColor"]
        for key in colorKeys {
            if !compareColorValues(key: key) {
                hasUnsavedChanges = true
                return
            }
        }
        
        // Check boolean and other values
        func compareStringValues(key: String) -> Bool {
            let loadedValue = loadedParams[key] ?? ""
            let currentValue = currentParams[key] ?? ""
            
            let matching = loadedValue == currentValue
            if !matching {
                print("[DEBUG] \(key) mismatch: loaded=\(loadedValue), current=\(currentValue)")
            }
            return matching
        }
        
        // Check boolean values and other string values
        let stringKeys = ["useRainbow", "rainbowStyle", "presetCount"]
        for key in stringKeys {
            if !compareStringValues(key: key) {
                hasUnsavedChanges = true
                return
            }
        }
        
        // Check adjustments
        if !compareDoubleValues(key: "hueAdj") || !compareDoubleValues(key: "satAdj") {
            hasUnsavedChanges = true
            return
        }
        
        // If we get here, everything matches (or is within acceptable tolerance)
        print("[DEBUG] All parameters match or are within tolerance - artwork is saved")
        hasUnsavedChanges = false
    }

    /// Makes an artwork info banner to display at the bottom of the screen
    private func makeArtworkInfoBanner() -> some View {
        HStack(spacing: 8) {
            if let loadedArtwork = loadedArtworkData {
                // Show artwork title
                Text(loadedArtwork.title ?? "Untitled Artwork")
                    .font(.headline)
                    .foregroundColor(.primary)
                    .lineLimit(1)
                
                // Show status indicator
                if hasUnsavedChanges {
                    // Show "Unsaved" in red when changes detected
                    Text("â¢ Unsaved")
                        .font(.caption)
                        .foregroundColor(.red)
                } else {
                    // Show "Saved" in green when no changes
                    Text("â¢ Saved")
                        .font(.caption)
                        .foregroundColor(.green)
                }
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(Color(.systemBackground).opacity(0.8))
        .cornerRadius(8)
        .shadow(radius: 1)
    }

    /// Debug method to compare raw artwork strings and identify conversion issues
    private func debugCompareArtworkStrings(loaded: String, current: String) {
        print("\n[DEBUG] =========== ARTWORK STRING COMPARISON ===========")
        print("[DEBUG] Loaded artwork: \(loaded)")
        print("[DEBUG] Current artwork: \(current)")
        
        if loaded == current {
            print("[DEBUG] Raw strings are IDENTICAL")
            return
        }
        
        print("[DEBUG] Raw strings are DIFFERENT")
        
        // Find where they first differ
        var differIndex = 0
        let minLength = min(loaded.count, current.count)
        
        for i in 0..<minLength {
            let loadedIndex = loaded.index(loaded.startIndex, offsetBy: i)
            let currentIndex = current.index(current.startIndex, offsetBy: i)
            
            if loaded[loadedIndex] != current[currentIndex] {
                differIndex = i
                break
            }
        }
        
        // Print the context around the difference
        let startContext = max(0, differIndex - 20)
        let endContext = min(minLength, differIndex + 20)
        
        print("[DEBUG] Difference starts at index \(differIndex)")
        
        if startContext < differIndex {
            let loadedContext = loaded[loaded.index(loaded.startIndex, offsetBy: startContext)..<loaded.index(loaded.startIndex, offsetBy: differIndex)]
            let currentContext = current[current.index(current.startIndex, offsetBy: startContext)..<current.index(current.startIndex, offsetBy: differIndex)]
            
            print("[DEBUG] Context before: ")
            print("[DEBUG] Loaded:  ...\(loadedContext)")
            print("[DEBUG] Current: ...\(currentContext)")
        }
        
        if differIndex < endContext {
            let loadedContext = loaded[loaded.index(loaded.startIndex, offsetBy: differIndex)..<loaded.index(loaded.startIndex, offsetBy: min(loaded.count, endContext))]
            let currentContext = current[current.index(current.startIndex, offsetBy: differIndex)..<current.index(current.startIndex, offsetBy: min(current.count, endContext))]
            
            print("[DEBUG] Context after: ")
            print("[DEBUG] Loaded:  \(loadedContext)...")
            print("[DEBUG] Current: \(currentContext)...")
        }
        
        print("[DEBUG] ===================================================\n")
    }

    /// Helper function to compare colors with visual tolerance
    private func areColorsVisuallyEquivalent(_ hex1: String, _ hex2: String) -> Bool {
        // Convert hex to RGB
        func hexToRGB(_ hex: String) -> (r: Int, g: Int, b: Int)? {
            var hexSanitized = hex.replacingOccurrences(of: "#", with: "")
            if hexSanitized.count != 6 {
                return nil
            }
            
            var rgb: UInt64 = 0
            guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else {
                return nil
            }
            
            let r = Int((rgb & 0xFF0000) >> 16)
            let g = Int((rgb & 0x00FF00) >> 8)
            let b = Int(rgb & 0x0000FF)
            
            return (r, g, b)
        }
        
        // Get RGB values
        guard let rgb1 = hexToRGB(hex1), let rgb2 = hexToRGB(hex2) else {
            // If can't parse, return direct comparison
            return hex1 == hex2
        }
        
        // Calculate color difference using a simple Euclidean distance in RGB space
        let rDiff = abs(rgb1.r - rgb2.r)
        let gDiff = abs(rgb1.g - rgb2.g)
        let bDiff = abs(rgb1.b - rgb2.b)
        
        // Calculate the Euclidean distance
        let distance = sqrt(Double(rDiff*rDiff + gDiff*gDiff + bDiff*bDiff))
        
        // Tolerance of 8 in RGB space (out of 255) should handle minor color variations
        let tolerance = 8.0
        let equivalent = distance <= tolerance
        
        if !equivalent {
            print("[DEBUG] Color difference: \(distance) - r:\(rDiff) g:\(gDiff) b:\(bDiff) between \(hex1) and \(hex2)")
        } else {
            print("[DEBUG] Colors equivalent within tolerance: \(hex1) and \(hex2) - distance: \(distance)")
        }
        
        return equivalent
    }

    // Add this method to execute the pending action
    private func executePendingAction() {
        guard let action = pendingAction else { return }
        
        switch action {
        case .newCanvas:
            performResetCanvasToDefault()
        case .importArtwork:
            showImportSheet = true
        case .loadGalleryArtwork(let artwork):
            performLoadArtwork(artwork: artwork)
        }
        
        // Clear the pending action and hide the alert
        pendingAction = nil
        showUnsavedChangesAlert = false
    }

    // Add this method to handle import menu click with unsaved changes check
    private func showImportMenu() {
        if hasUnsavedChanges {
            setShowUnsavedChangesAlert(action: .importArtwork)
        } else {
            showImportSheet = true
        }
    }

    private func getAlertMessage() -> String {
        guard let pendingAction = pendingAction else {
            return "You have unsaved changes that will be lost."
        }
        
        switch pendingAction {
        case .newCanvas:
            return "You have unsaved changes that will be lost if you create a new canvas."
        case .importArtwork:
            return "You have unsaved changes that will be lost if you import new artwork."
        case .loadGalleryArtwork:
            return "You have unsaved changes that will be lost if you load artwork from the gallery."
        }
    }

    // Add method to update the pendingAction and show the alert
    private func setShowUnsavedChangesAlert(action: PendingAction) {
        pendingAction = action
        showUnsavedChangesAlert = true
    }
}

/// Helper for share/import button appearance
@ViewBuilder
private func buttonIcon(systemName: String) -> some View {
    VStack {
        Image(systemName: systemName)
            .font(.system(size: 20))
            .foregroundColor(Color(uiColor: .systemBlue))
    }
    .padding(8)
    .frame(width: 40, height: 40)
    .background(Color(uiColor: .systemBackground))
    .cornerRadius(8)
    .overlay(
        RoundedRectangle(cornerRadius: 8)
            .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
    )
}

// MARK: - Artwork Replace Sheet

struct ArtworkReplaceSheet: View {
    let artworks: [ArtworkData]
    let thumbnails: [String: UIImage]
    let onSelect: (ArtworkData) -> Void
    let onCancel: () -> Void
    
    // Formatter for timestamp
    private static let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter
    }()
    
    var body: some View {
        NavigationView {
            List {
                Section(header: Text("Select an artwork to replace:")) {
                    ForEach(artworks) { artwork in
                        Button(action: {
                            onSelect(artwork)
                        }) {
                            HStack {
                                // Add a preview of the artwork
                                ArtworkPreview(artwork: artwork, thumbnail: thumbnails[artwork.id])
                                    .frame(width: 50, height: 50)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color(uiColor: .systemGray3), lineWidth: 0.5)
                                    )
                                
                                VStack(alignment: .leading) {
                                    Text(artwork.title ?? "Untitled")
                                        .font(.headline)
                                    Text("Last modified: \(Self.dateFormatter.string(from: artwork.timestamp))")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                                Spacer()
                                Image(systemName: "arrow.forward.circle")
                                    .foregroundColor(.blue)
                            }
                            .contentShape(Rectangle())
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
            }
            .listStyle(InsetGroupedListStyle())
            .navigationTitle("Gallery Full")
            .navigationBarItems(
                trailing: Button("Cancel") {
                    onCancel()
                }
            )
        }
    }
}

// New view to render artwork preview
struct ArtworkPreview: View {
    let artwork: ArtworkData
    let thumbnail: UIImage?
    
    var body: some View {
        if let thumbnailImage = thumbnail {
            // Use the pre-rendered thumbnail
            Image(uiImage: thumbnailImage)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .background(Color(.systemBackground))
        } else {
            // Fallback if no thumbnail is available
            ZStack {
                Color.gray.opacity(0.3)
                Image(systemName: "photo")
                    .foregroundColor(.gray)
            }
        }
    }
}

// Add ArtworkParameters struct to support the ArtworkPreview view
private struct ArtworkParameters {
    let shapeType: ShapesPanel.ShapeType
    let rotation: Double
    let scale: Double
    let layer: Double
    let skewX: Double
    let skewY: Double
    let spread: Double
    let horizontal: Double
    let vertical: Double
    let primitive: Double
    let colorPresets: [Color]
    let backgroundColor: Color
    let useDefaultRainbowColors: Bool
    let rainbowStyle: Int
    let hueAdjustment: Double
    let saturationAdjustment: Double
    let shapeAlpha: Double
    let strokeWidth: Double
    let strokeColor: Color
}

// ArtworkRendererView for rendering thumbnails
private struct ArtworkRendererView: View {
    let params: ArtworkParameters
    // Define the rendering size
    private let renderSize = CGSize(width: 100, height: 100)
    
    var body: some View {
        Canvas { context, size in
            // Fill background
            context.fill(Path(CGRect(origin: .zero, size: size)), with: .color(params.backgroundColor))
            // Draw the shapes
            drawShapes(context: context, size: size, params: params)
        }
        .frame(width: renderSize.width, height: renderSize.height)
    }
    
    // MARK: - Drawing Logic
    private func drawShapes(context: GraphicsContext, size: CGSize, params: ArtworkParameters) {
        let circleRadius = 10.0 // Smaller radius for thumbnails
        let centerX = size.width / 2
        let centerY = size.height / 2
        let center = CGPoint(x: centerX, y: centerY)
        
        let numberOfLayers = max(0, min(72, Int(params.layer)))
        if numberOfLayers > 0 {
            drawLayers(
                context: context,
                layers: numberOfLayers,
                center: center,
                radius: circleRadius,
                params: params
            )
        }
    }
    
    private func drawLayers(
        context: GraphicsContext,
        layers: Int,
        center: CGPoint,
        radius: Double,
        params: ArtworkParameters
    ) {
        let primitiveCount = Int(max(1.0, min(6.0, params.primitive)))
        
        for layerIndex in 0..<layers {
            for primitiveIndex in 0..<primitiveCount {
                let primitiveAngleOffset = (360.0 / Double(primitiveCount)) * Double(primitiveIndex)
                drawSingleShape(
                    context: context,
                    layerIndex: layerIndex,
                    primitiveAngleOffset: primitiveAngleOffset,
                    center: center,
                    radius: radius,
                    params: params
                )
            }
        }
    }
    
    private func drawSingleShape(
        context: GraphicsContext,
        layerIndex: Int,
        primitiveAngleOffset: Double,
        center: CGPoint,
        radius: Double,
        params: ArtworkParameters
    ) {
        let angleInDegrees = (params.rotation * Double(layerIndex)) + primitiveAngleOffset
        let angleInRadians = angleInDegrees * (.pi / 180)
        
        let scaleFactor = 0.25
        let layerScale = pow(1.0 + (params.scale - 1.0) * scaleFactor, Double(layerIndex + 1))
        let scaledRadius = radius * layerScale
        
        let spreadDistance = max(params.spread * Double(layerIndex), Double(layerIndex))
        let spreadX = spreadDistance * cos(angleInRadians)
        let spreadY = spreadDistance * sin(angleInRadians)
        
        let finalX = center.x + scaledRadius * cos(angleInRadians) + spreadX + params.horizontal
        let finalY = center.y + scaledRadius * sin(angleInRadians) + spreadY - params.vertical
        
        let baseRect = CGRect(
            x: finalX - scaledRadius,
            y: finalY - scaledRadius,
            width: scaledRadius * 2,
            height: scaledRadius * 2
        )
        
        // Create shape path based on type
        let shapePath: Path
        switch params.shapeType {
        case .circle:
            shapePath = Path(ellipseIn: baseRect)
        case .square:
            shapePath = Path(baseRect)
        case .triangle:
            var path = Path()
            path.move(to: CGPoint(x: finalX, y: finalY - scaledRadius))
            path.addLine(to: CGPoint(x: finalX - scaledRadius, y: finalY + scaledRadius))
            path.addLine(to: CGPoint(x: finalX + scaledRadius, y: finalY + scaledRadius))
            path.closeSubpath()
            shapePath = path
        case .hexagon:
            shapePath = createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 6)
        case .star:
            shapePath = createStarPath(center: CGPoint(x: finalX, y: finalY), innerRadius: scaledRadius * 0.4, outerRadius: scaledRadius, points: 5)
        case .pentagon:
            shapePath = createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 5)
        case .octagon:
            shapePath = createPolygonPath(center: CGPoint(x: finalX, y: finalY), radius: scaledRadius, sides: 8)
        default:
            // Default to circle for other shapes to keep it simple
            shapePath = Path(ellipseIn: baseRect)
        }
        
        // Apply transformations
        var shapeTransform = CGAffineTransform.identity
        
        if abs(angleInRadians) > 0.001 {
            shapeTransform = shapeTransform.rotated(by: CGFloat(angleInRadians))
        }
        
        // Apply skew if needed
        if abs(params.skewX) > 0.01 || abs(params.skewY) > 0.01 {
            let skewXRad = (params.skewX / 100.0) * (.pi / 15)
            let skewYRad = (params.skewY / 100.0) * (.pi / 15)
            
            if abs(params.skewX) > 0.01 {
                let shearX = CGFloat(tan(skewXRad))
                shapeTransform = shapeTransform.concatenating(CGAffineTransform(a: 1, b: 0, c: shearX, d: 1, tx: 0, ty: 0))
            }
            
            if abs(params.skewY) > 0.01 {
                let shearY = CGFloat(tan(skewYRad))
                shapeTransform = shapeTransform.concatenating(CGAffineTransform(a: 1, b: shearY, c: 0, d: 1, tx: 0, ty: 0))
            }
        }
        
        // Apply the complete transform
        let toOriginTransform = CGAffineTransform(translationX: -finalX, y: -finalY)
        let backToPositionTransform = CGAffineTransform(translationX: finalX, y: finalY)
        let finalTransform = toOriginTransform.concatenating(shapeTransform).concatenating(backToPositionTransform)
        let transformedPath = shapePath.applying(finalTransform)
        
        // Determine color for this layer
        let layerColor: Color
        if params.useDefaultRainbowColors {
            // Use rainbow colors based on style
            switch params.rainbowStyle {
            case 1: layerColor = ColorUtils.cyberpunkRainbowColor(for: layerIndex, hueAdjustment: params.hueAdjustment, saturationAdjustment: params.saturationAdjustment)
            case 2: layerColor = ColorUtils.halfSpectrumRainbowColor(for: layerIndex, hueAdjustment: params.hueAdjustment, saturationAdjustment: params.saturationAdjustment)
            default: layerColor = ColorUtils.rainbowColor(for: layerIndex, hueAdjustment: params.hueAdjustment, saturationAdjustment: params.saturationAdjustment)
            }
        } else {
            // Use presets
            if !params.colorPresets.isEmpty {
                let colorIndex = layerIndex % params.colorPresets.count
                layerColor = params.colorPresets[colorIndex]
            } else {
                layerColor = .gray // Fallback
            }
        }
        
        // Draw the shape
        let baseOpacity = params.shapeAlpha
        let layerOpacity = layerIndex == 0 ? baseOpacity : baseOpacity * 0.8
        
        context.fill(transformedPath, with: .color(layerColor.opacity(layerOpacity)))
        
        // Apply stroke if needed
        if params.strokeWidth > 0 {
            context.stroke(
                transformedPath,
                with: .color(params.strokeColor),
                lineWidth: CGFloat(params.strokeWidth)
            )
        }
    }
    
    // Helper to create polygon paths
    private func createPolygonPath(center: CGPoint, radius: Double, sides: Int) -> Path {
        var path = Path()
        let angle = (2.0 * .pi) / Double(sides)
        for i in 0..<sides {
            let currentAngle = angle * Double(i) - (.pi / 2)
            let x = center.x + CGFloat(radius * cos(currentAngle))
            let y = center.y + CGFloat(radius * sin(currentAngle))
            if i == 0 { path.move(to: CGPoint(x: x, y: y)) }
            else { path.addLine(to: CGPoint(x: x, y: y)) }
        }
        path.closeSubpath()
        return path
    }
    
    // Helper to create star paths
    private func createStarPath(center: CGPoint, innerRadius: Double, outerRadius: Double, points: Int) -> Path {
        var path = Path()
        let totalPoints = points * 2
        let angle = (2.0 * .pi) / Double(totalPoints)
        for i in 0..<totalPoints {
            let radius = i % 2 == 0 ? outerRadius : innerRadius
            let currentAngle = angle * Double(i) - (.pi / 2)
            let x = center.x + CGFloat(radius * cos(currentAngle))
            let y = center.y + CGFloat(radius * sin(currentAngle))
            if i == 0 { path.move(to: CGPoint(x: x, y: y)) }
            else { path.addLine(to: CGPoint(x: x, y: y)) }
        }
        path.closeSubpath()
        return path
    }
}
